{
    "contents" : "###################################################################################################\n# Creating simulated networks\n###################################################################################################\n\nrequire(igraph)\n# GLOBAL VARIABLES\n\nGLOBAL_ADJ_BEFORE <- NULL   # Adjacency matrix before adding noise\nGLOBAL_ADJ_AFTER <- NULL    # Adjacency matrix after adding noise\nGLOBAL_ADJ_BEFORE_D <- NULL # Directed versions of adjacency matrix\nGLOBAL_ADJ_AFTER_D <- NULL  # Directed versions of adjacency matrix\n\n###################################################################################################\n# Main Simulations\n\n# mainSimU:\n#   Main simulation function to run the undirected version a certain time\n#\n# Inputs:\n#   n: number of times to run the simulation\nmainSimU <- function(n=1) {\n  all_data <- vector(\"list\", n)   # Vector with all simulation data\n  sim_data <- vector(\"list\", 4)   # Vector for each graph\n  \n  for(i in 1:n) {\n    t <- proc.time()            # Timer\n    \n    myGraph <- SimGraphU(FALSE) # Don't display plots every time\n    X <- myGraph[[1]]\n    bridge_lst <- myGraph[[2]]\n    myComm <- comm_struct(rownames(as_adjacency_matrix(X, type=\"both\")))\n    \n    sim_data[[1]] <- GLOBAL_ADJ_BEFORE\n    sim_data[[2]] <- GLOBAL_ADJ_AFTER\n    sim_data[[3]] <- myComm\n    sim_data[[4]] <- bridge_lst\n    \n    all_data[[i]] <- sim_data\n    \n    print(proc.time() - t)\n  }\n  \n  return(all_data)\n}\n\n# mainSimD:\n#   Main simulation function to run the directed version a certain time\n#\n# Inputs:\n#   n: number of times to run the simulation\nmainSimD <- function(n=1) {\n  all_data <- vector(\"list\", n)   # Vector with all simulation data\n  sim_data <- vector(\"list\", 4)   # Vector for each graph\n  \n  for(i in 1:n) {\n    t <- proc.time()            # Timer\n    \n    myGraph <- SimGraphD(FALSE) # Don't display plots every time\n    X <- myGraph[[1]]\n    bridge_lst <- myGraph[[2]]\n    myComm <- comm_struct(rownames(as_adjacency_matrix(X, type=\"both\")))\n    \n    sim_data[[1]] <- GLOBAL_ADJ_BEFORE_D\n    sim_data[[2]] <- GLOBAL_ADJ_AFTER_D\n    sim_data[[3]] <- myComm\n    sim_data[[4]] <- bridge_lst\n    \n    all_data[[i]] <- sim_data\n    \n    print(proc.time() - t)\n  }\n  \n  return(all_data)\n}\n\n###################################################################################################\n# Helper Functions\n\n# get_comm:\n#   Given a node name, return the community as a scalar (i.e. a=1, b=2, etc.)\n#\n# Inputs:\n#   v_name: name of node\nget_comm <- function(v_name) {\n  com_name <- substr(v_name, 1, 1)     # community name of node\n  scalar <- strtoi(charToRaw(com_name)) - strtoi(charToRaw(\"a\")) + 1\n  \n  return(scalar)\n}\n\n# comm_struct:\n#   Given a list of node names, return the community structure composed of\n#   scalars representing which community node is part of\n#\n# Inputs:\n#   v_names: list of node names\ncomm_struct <- function(v_names) {\n  scalar_lst <- lapply(v_names, get_comm)\n  \n  return(scalar_lst)\n}\n\n# Randomize number of vertices in each community\n# Community_list returns a list of sizes (5-20) of complete graphs\n# lst[[i]] returns the i^th item in the list\ncommunity_list <- function(graph_num){\n  size_list <- vector(\"list\", graph_num)\n  for (i in 1:graph_num) {\n    ComGraph <- sample(6:21, 1) #clusters would be of size 5-20, as Node 1 is the default bridge\n    size_list[i]<-ComGraph\n  }\n  size_list\n}\n\n# todirected:\n#   Returns a directed graph from an undirected graph as input\n#\n# Inputs:\n#   X:  An undirected graph\ntodirected <- function(X, bridge_lst) {\n  A <- as_adjacency_matrix(X, type=\"both\")\n  Y <- graph_from_adjacency_matrix(A, mode=\"directed\")\n  V(Y)[bridge_lst]$color <- \"lightgreen\"\n  \n  return(Y)\n}\n\n# graphstructure:\n#   Returns an undirected graph of communities and bridges given size dimensions as inputs\n#   \n# Inputs:\n#   Com_size      number of communities in the graph\n#   size_list     list of nodes in each community\n#   bridge_size   number of bridges that connect to communities\ngraphstructure <- function(Com_size, size_list, bridge_size) {\n  \n  # Define variables\n  X <- make_empty_graph(n=0, directed = FALSE)        # Return graph\n  bridge_lst <- NULL                                  # List of bridges in graph\n  Com_graph_lst <- lapply(size_list, make_full_graph) # Complete graphs of communities\n  sameCom <- 0.75                                     # Same community ratio\n  diffCom <- 0.25                                     # Different community ratio\n  \n  # Label vertices in the communities, and add to graph\n  for (i in 1:Com_size) {\n    Com_graph_lst[[i]] = set_vertex_attr(Com_graph_lst[[i]], \"name\", value=paste(letters[i], 1:size_list[[i]], sep=\"\"))\n    X <- X + Com_graph_lst[[i]]\n  }\n  \n  # Add bridges\n  for (i in 1:bridge_size) {\n    my_com <- sample(1:Com_size, 1)     # Pick community randomly\n    my_vertex <- paste(letters[my_com], size_list[[my_com]] + 1, sep=\"\")\n    print(paste(\"Bridge \", my_vertex, \" belongs to community \", letters[my_com], sep=\"\"))\n    \n    # Add vertex\n    X <- add_vertices(X, 1, name=my_vertex)\n    bridge_lst <- c(bridge_lst, my_vertex)\n    \n    # Add edges to all communities\n    for (j in 1:Com_size) {\n      my_comSize <- size_list[[j]]    # Size of community\n      bridge_vertices <- NULL         # Corresponding vertices that connects with bridge\n      bridge_edges <- NULL            # Corresponding edges\n      \n      # Community bridge belongs to\n      if (j == my_com) {\n        bridge_vertices <- sample(1:my_comSize, ceiling(sameCom * my_comSize))\n        \n        # Not community bridge belongs to\n      } else {\n        bridge_vertices <- sample(1:my_comSize, floor(diffCom * my_comSize))\n      }\n      \n      for (v in bridge_vertices) {\n        c_vertex <- paste(letters[j], v, sep=\"\")\n        bridge_edges <- c(bridge_edges, my_vertex, c_vertex)\n      }\n      \n      # Add Edges\n      X <- add_edges(X, bridge_edges)\n      \n      print(paste(\"-- \", my_vertex, \": Added \", length(bridge_vertices), \" edges to community \", letters[j], \"(\", round(length(bridge_vertices)/size_list[[j]] * 100, digits=2), \"%)\", sep=\"\"))\n    }\n    \n    # Make new vertex available\n    size_list[[my_com]] <- size_list[[my_com]] + 1\n  }\n  \n  # Print Community sizes\n  print(\"New community sizes:\")\n  for (i in 1:Com_size) {\n    print(paste(\"Community \", letters[i], \": \", size_list[[i]], sep=\"\"))\n  }\n  \n  V(X)[bridge_lst]$color <- \"lightgreen\"\n  \n  X <- simplify(X)\n  \n  return(list(X, bridge_lst))\n}\n\n# isSameCom:\n#   Returns true if v and w belong to the same community, otherwise false\n#\n# Inputs:\n#   v:  name/label of first node (string type)\n#   w:  name/label of second node (string type)\nisSameCom <- function(v, w) {\n  comV <- substr(v, 1, 1)     # community name of node v\n  comW <- substr(w, 1, 1)     # community name of node w\n  result <- FALSE\n  \n  if (comV == comW) {\n    result <- TRUE\n  }\n  \n  return(result)\n}\n\n# WeightedGraphU:\n#   Adds weight to undirected input graph X, and returns new graph with weights.\n#\n# Inputs:\n#   X:          Graph without weights added\n#   bridge_lst: List of bridges\nWeightedGraphU <- function(X, bridge_lst) {\n  \n  A <- as_adjacency_matrix(X, type=\"both\")\n  m <- nrow(A)\n  n <- ncol(A)\n  rnames <- rownames(A)\n  cnames <- colnames(A)\n  \n  # Assign weight to each edge\n  for (i in 1:m) {\n    for (j in 1:i) {\n      \n      # Skip if self-loop or no edge currently exists\n      if ((i == j) || (A[i,j] == 0)) {\n        next\n      }\n      \n      r <- rnames[i]\n      c <- cnames[j]\n      \n      # Case 1: Edge belongs to bridge and community it belongs to\n      if ((r %in% bridge_lst) && isSameCom(r, c))  {\n        A[i,j] <- runif(1, 0.5, 1) # Random number from 0.5 to 1\n      }\n      \n      # Case 2: Edge belongs to bridge and community it doesn't belong to\n      else if ((r %in% bridge_lst) && !isSameCom(r, c)) {\n        A[i,j] <- runif(1, 0, 0.5) # Random number from 0 to 0.5\n        \n        # Less than 0.1, make 0\n        if (A[i,j] < 0.1) {\n          A[i,j] <- 0\n        }\n      }\n      \n      # Case 3: Edge between non-bridge vertices\n      else {\n        A[i,j] <- runif(1, 0, 1) # Random number from 0 and 1\n        \n        # Less than 0.1, make 0\n        if (A[i,j] < 0.1) {\n          A[i,j] <- 0\n        }\n      }\n      \n      # \"Reflect\" edge weights across adjacency matrix\n      A[j,i] <- A[i,j]\n    }\n  }\n  \n  assign(\"GLOBAL_ADJ_BEFORE\", A, envir=.GlobalEnv)\n  \n  # Add noise\n  for (i in 1:m) {\n    for (j in 1:i) {\n      if (i != j) {\n        A[i,j] <- abs(A[i,j] + rnorm(1, mean = 0, sd = 0.05))   # Add noise\n        A[j,i] <- A[i,j]                                        # Reflect edge weights\n      }\n    }\n  }\n  \n  assign(\"GLOBAL_ADJ_AFTER\", A, envir=.GlobalEnv)\n  \n  X <- graph_from_adjacency_matrix(A, mode=\"undirected\", weighted=TRUE)\n  V(X)[bridge_lst]$color <- \"lightgreen\"\n  \n  return(X)\n}\n\n# WeightedGraphD:\n#   Adds weight to directed input graph X, and returns new graph with weights.\n#\n# Inputs:\n#   X:          Graph without weights added\n#   bridge_lst: List of bridges\nWeightedGraphD <- function(X, bridge_lst) {\n  \n  A <- as_adjacency_matrix(X, type=\"both\")\n  m <- nrow(A)\n  n <- ncol(A)\n  rnames <- rownames(A)\n  cnames <- colnames(A)\n  \n  # Assign weight to each edge\n  for (i in 1:m) {\n    for (j in 1:n) {\n      \n      # Skip if self-loop or no edge currently exists\n      if ((i == j) || (A[i,j] == 0)) {\n        next\n      }\n      \n      r <- rnames[i]\n      c <- cnames[j]\n      \n      # Case 1: Edge belongs to bridge and community it belongs to\n      if (((r %in% bridge_lst) && isSameCom(r, c)) || ((c %in% bridge_lst) && isSameCom(c, r)))  {\n        A[i,j] <- runif(1, 0.5, 1) # Random number from 0.5 to 1\n      }\n      \n      # Case 2: Edge belongs to bridge and community it doesn't belong to\n      else if (((r %in% bridge_lst) && !isSameCom(r, c)) || ((c %in% bridge_lst) && !isSameCom(c, r))){\n        A[i,j] <- runif(1, 0, 0.5) # Random number from 0 to 0.5\n        \n        # Less than 0.1, make 0\n        if (A[i,j] < 0.1) {\n          A[i,j] <- 0\n        }\n      }\n      \n      # Case 3: Edge between non-bridge vertices\n      else {\n        A[i,j] <- runif(1, 0, 1) # Random number from 0 and 1\n        \n        # Less than 0.1, make 0\n        if (A[i,j] < 0.1) {\n          A[i,j] <- 0\n        }\n      }\n    }\n  }\n  \n  assign(\"GLOBAL_ADJ_BEFORE_D\", A, envir=.GlobalEnv)\n  \n  for (i in 1:m) {\n    for (j in 1:n) {\n      if (i != j) {\n        A[i,j] <- abs(A[i,j] + rnorm(1, mean = 0, sd = 0.05))   # Add noise\n      }\n    }\n  }\n  \n  assign(\"GLOBAL_ADJ_AFTER_D\", A, envir=.GlobalEnv)\n  \n  X <- graph_from_adjacency_matrix(A, mode=\"directed\", weighted=TRUE)\n  V(X)[bridge_lst]$color <- \"lightgreen\"\n  \n  return(X)\n}\n\n# SimGraphU:\n#   Returns an undirected graph of communities and bridges \n#   \n# Inputs:\n#   showPlot:   Displays plot to screen if default or true\nSimGraphU <- function(showPlot=TRUE) {\n  \n  # Determine graph attributes\n  Com_size <- sample(2:5, 1)            # Number of communites in network\n  size_list <- community_list(Com_size) # Size of each community\n  bridge_size <- sample(1:5, 1)         # Number of bridges\n  \n  # Print graph attributes\n  print(paste(\"Graphing with \", Com_size, \" communities and \", bridge_size, \" bridges\", sep=\"\"))\n  for (i in 1:Com_size) {\n    print(paste(\"Community \", letters[i], \": \", size_list[[i]], sep=\"\"))\n  }\n  \n  # Graph and plot (# WARNING: size_list has changed due to the addition of bridges)\n  myGraph <- graphstructure(Com_size, size_list, bridge_size)\n  \n  X <- myGraph[[1]]\n  bridge_lst <- myGraph[[2]]\n  \n  # Change edge weights\n  X <- WeightedGraphU(X, bridge_lst)\n  \n  if (showPlot == TRUE) {\n    l <- layout_with_fr(X)\n    plot(X, layout=l)\n  }\n  \n  return(list(X, bridge_lst))\n}\n\n# SimGraphD:\n#   Returns a directed graph of communities and bridges \n#   \n# Inputs:\n#   None\nSimGraphD <- function(showPlot=TRUE) {\n  \n  # Determine graph attributes\n  Com_size <- sample(2:5, 1)            # Number of communites in network\n  size_list <- community_list(Com_size) # Size of each community\n  bridge_size <- sample(1:5, 1)         # Number of bridges\n  \n  # Print graph attributes\n  print(paste(\"Graphing with \", Com_size, \" communities and \", bridge_size, \" bridges\", sep=\"\"))\n  for (i in 1:Com_size) {\n    print(paste(\"Community \", letters[i], \": \", size_list[[i]], sep=\"\"))\n  }\n  \n  # Graph and plot (# WARNING: size_list has changed due to the addition of bridges)\n  myGraph <- graphstructure(Com_size, size_list, bridge_size)\n  \n  X <- todirected(myGraph[[1]], myGraph[[2]]) # Convert X to a directed graph\n  bridge_lst <- myGraph[[2]]\n  \n  # Change edge weights\n  X <- WeightedGraphD(X, bridge_lst)\n  \n  if (showPlot == TRUE) {\n    l <- layout_with_fr(X)\n    plot(X, layout=l, edge.arrow.size=0.1)\n  }\n  \n  return(list(X, bridge_lst))\n}\n\n## Run the functions to generate simulated networks (takes a long time):\n#undir_simulations <- mainSimU(500)\n#dir_simulations <- mainSimD(500)\n\n###################################################################################################\n# Checking the simulations for sensitivity & specificity\n###################################################################################################\n\nrequire(networktools)\nrequire(igraph)\n\n#################################\n## What is contained in each output:\nout <- mainSimU(1)\nas.matrix(out[[1]][[1]]) ## adjacency matrix (no noise)\nas.matrix(out[[1]][[2]]) ## adjacency matrix (noise)\nunlist(out[[1]][[3]]) ## community structure\nout[[1]][[4]] ## true bridges\n\n## Create a representative plot:\nnet <- as.matrix(undir_simulations[[8]][[1]])\nbridges <- undir_simulations[[8]][[4]]\nbridges \ndim(net)\ncolnames(net) %in% bridges\nnet2 <- as.matrix(undir_simulations[[8]][[2]])\n\nop <- par(mfrow=c(1,2))\nqgraph(net, layout=\"spring\", groups=list(\"Nodes\"=c(1:68), \"Bridge Nodes\"=c(69:73)), colors=c(\"lightblue\", \"lightsalmon\"), legend=FALSE)\nqgraph(net2, layout=\"spring\", groups=list(\"Nodes\"=c(1:68), \"Bridge Nodes\"=c(69:73)), colors=c(\"lightblue\", \"lightsalmon\"), legend=FALSE)\npar(op)\n\n#################################\n## Necessary functions\n\n# \"not in\" function\n'%!in%' <- function(x,y)!('%in%'(x,y)) \n\n# returns sensitivity and specificity, given character vectors as input\nsens_spec <- function(all, predicted, actual) {\n  predicted_negatives <- all[all %!in% predicted]\n  actual_negatives <- all[all %!in% actual]\n  \n  true_pos <- sum(predicted %in% actual)\n  true_neg <- sum(predicted_negatives %in% actual_negatives)\n  \n  # sensitivity = true positives over total positives \n  sensitivity <- true_pos/length(actual)\n  # specificity = true negatives over total negatives \n  specificity <- true_neg/length(actual_negatives)\n  return(c(sensitivity, specificity))\n}\n\n# given centrality values, determines predicted bridges (combined criteria, & separate)\n\npredict_bridge <- function(strength, between, close) {\n  strength_c <- names(strength[strength>quantile(strength, probs=0.75, na.rm=TRUE)])\n  between_c <- names(between[between>quantile(between, probs=0.75, na.rm=TRUE)])\n  close_c <- names(close[close>quantile(close, probs=0.75, na.rm=TRUE)])\n  pred_combined <- intersect(intersect(strength_c,between_c),close_c)\n  \n  pred_strength <- names(strength[strength>quantile(strength, probs=0.80, na.rm=TRUE)])\n  pred_between <- names(between[between>quantile(between, probs=0.80, na.rm=TRUE)])\n  pred_close <- names(close[close>quantile(close, probs=0.80, na.rm=TRUE)])\n  \n  return(list(pred_combined=pred_combined,pred_strength=pred_strength,pred_between=pred_between,pred_close=pred_close))\n}\n\n\n# returns sensitivity and specificity for each of several listed cases\ncheck_bridge <- function(x, directed=FALSE) {\n  out_table <- matrix(rep(NA,32),16,2)\n  try({\n    rownames(out_table) <- c(\"1.1\",\"1.2\",\"1.3\",\"1.4\",\"2.1\",\"2.2\",\"2.3\",\"2.4\",\"3.1\",\"3.2\",\"3.3\",\"3.4\",\"4.1\",\"4.2\",\"4.3\",\"4.4\")\n    colnames(out_table) <- c(\"Sensitivity\", \"Specificity\")\n    all <- colnames(as.matrix(x[[1]]))\n    actual <- x[[4]]\n    \n    ## Case 1 = communities prespecified, no noise\n    b1 <- bridge(as.matrix(x[[1]]), communities= unlist(x[[3]]), directed=directed) # w/communities\n    strength <- b1$'Bridge Strength'; between <- b1$'Bridge Betweenness'; close <- b1$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    ### 1.1 = combined criteria\n    out_table[1, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    ### 1.2 = strength only\n    out_table[2, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    ### 1.3 = betweenness only\n    out_table[3, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    ### 1.4 = closeness only\n    out_table[4, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 2 = communities not specified, no noise\n    b2 <- bridge(as.matrix(x[[1]]), directed=directed) \n    strength <- b2$'Bridge Strength'; between <- b2$'Bridge Betweenness'; close <- b2$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[5, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[6, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[7, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[8, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 3 = communities prespecified, noise\n    b3 <- bridge(as.matrix(x[[2]]), communities= unlist(x[[3]]), directed=directed) \n    strength <- b3$'Bridge Strength'; between <- b3$'Bridge Betweenness'; close <- b3$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[9, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[10, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[11, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[12, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 4 = communities not specified, noise\n    b4 <- bridge(as.matrix(x[[2]]), directed=directed)\n    strength <- b4$'Bridge Strength'; between <- b4$'Bridge Betweenness'; close <- b4$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[13, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[14, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[15, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[16, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n  })\n  return(out_table)\n}\n\n#################################\n## Testing simulations (takes a long time)\n\nundir_tests <- lapply(undir_simulations, FUN=check_bridge)\ndir_tests <- lapply(undir_simulations, FUN=check_bridge, directed=TRUE)\n\n#################################\n## Averages, full table\nav_mat_undir <- matrix(rep(NA, 32), 16,2)\nav_mat_dir <- matrix(rep(NA, 32), 16,2)\nfor(i in 1:16) {\n  for(j in 1:2){\n    vec1 <- sapply(undir_tests, function(l) l[i,j])\n    av_mat_undir[i,j] <- mean(na.omit(vec1))\n    vec2 <- sapply(dir_tests, function(l) l[i,j])\n    av_mat_dir[i,j] <- mean(na.omit(vec2))\n  }\n}\n\nav_mat_undir\nav_mat_dir\n\nfulltable <- as.data.frame(matrix(rep(NA, 32*6), 32, 6))\ncolnames(fulltable) <- c(\"Directed?\", \"Comm. Prespecified?\", \"Noise?\", \"Criteria\", \"Sensitivity\", \"Specificity\")\nfulltable[1:16,5:6] <- av_mat_undir\nfulltable[17:32, 5:6] <- av_mat_dir\nfulltable$'Directed?' <- c(rep(\"Undirected\", 16), rep(\"Directed\", 16))\nfulltable$'Criteria' <- rep(c(\"Combined\", \"Strength\", \"Betweenness\", \"Closeness\"),8)\nfulltable$'Comm. Prespecified?' <- rep(c(rep(c(\"Yes\"), 4), rep(c(\"No\"), 4)), 4)\nfulltable$'Noise?' <- rep(c(rep(\"No\", 8), rep(\"Yes\", 8)), 2)\n\nfulltable <- fulltable[fulltable$Criteria %!in% c(\"Combined\"),]\nwrite.csv(fulltable, file=\"Sensitivity Specificity, Positive Networks.csv\")\n\n## Averages of averages\nfulltable2 <- matrix(rep(NA, 20),10,2)\nfulltable2[1,1]<-mean(fulltable$Sensitivity)\nfulltable2[1,2]<-mean(fulltable$Specificity)\n\nfulltable2[2,1]<-mean(fulltable$Sensitivity[fulltable$`Directed?`==\"Undirected\"])\nfulltable2[2,2]<-mean(fulltable$Specificity[fulltable$`Directed?`==\"Undirected\"])\nfulltable2[3,1]<-mean(fulltable$Sensitivity[fulltable$`Directed?`==\"Directed\"])\nfulltable2[3,2]<-mean(fulltable$Specificity[fulltable$`Directed?`==\"Directed\"])\n\nfulltable2[4,1]<-mean(fulltable$Sensitivity[fulltable$`Comm. Prespecified?`==\"Yes\"])\nfulltable2[4,2]<-mean(fulltable$Specificity[fulltable$`Comm. Prespecified?`==\"Yes\"])\nfulltable2[5,1]<-mean(fulltable$Sensitivity[fulltable$`Comm. Prespecified?`==\"No\"])\nfulltable2[5,2]<-mean(fulltable$Specificity[fulltable$`Comm. Prespecified?`==\"No\"])\n\nfulltable2[6,1]<-mean(fulltable$Sensitivity[fulltable$`Noise?`==\"Yes\"])\nfulltable2[6,2]<-mean(fulltable$Specificity[fulltable$`Noise?`==\"Yes\"])\nfulltable2[7,1]<-mean(fulltable$Sensitivity[fulltable$`Noise?`==\"No\"])\nfulltable2[7,2]<-mean(fulltable$Specificity[fulltable$`Noise?`==\"No\"])\n\nfulltable2[8,1]<-mean(fulltable$Sensitivity[fulltable$Criteria==\"Strength\"])\nfulltable2[8,2]<-mean(fulltable$Specificity[fulltable$Criteria==\"Strength\"])\n\nfulltable2[9,1]<-mean(fulltable$Sensitivity[fulltable$Criteria==\"Betweenness\"])\nfulltable2[9,2]<-mean(fulltable$Specificity[fulltable$Criteria==\"Betweenness\"])\n\nfulltable2[10,1]<-mean(fulltable$Sensitivity[fulltable$Criteria==\"Closeness\"])\nfulltable2[10,2]<-mean(fulltable$Specificity[fulltable$Criteria==\"Closeness\"])\n\nfulltable2\n\n\n##############################################################\n## Simulations with negative edges (bridge expected influence)\n\nei_undirected <- mainSimU(500)\nei_directed <- mainSimD(500)\n\n## Turn some of those edges into negatives\nmakesomeneg <- function(x, percent=80){\n  noiseless <- as.matrix(x[[1]])\n  noisy <- as.matrix(x[[1]])\n  for(i in 1:dim(noisy)[1]){\n    for(j in 1:dim(noisy)[2]){\n      noisy[i,j] <- makesomeneg2(noisy[i,j], percent)\n      noiseless[i,j] <- makesomeneg2(noiseless[i,j], percent) \n    }\n  }\n  res <- x\n  res[[1]] <- noiseless\n  res[[2]] <- noisy\n  return(res)\n}\nmakesomeneg2 <- function(x, percent=80){\n  if(sample(c(0:100),1)>percent){\n    x <- -1*x\n  }else{}\n  return(x)\n}\n\nundir_sim_neg <- lapply(ei_undirected, FUN=makesomeneg)\ndir_sim_neg <- lapply(ei_undirected, FUN=makesomeneg)\n\n## Change prediction algorithm so \"strength\" now means EI1\n## and \"between\" now means EI2\ncheck_bridge2 <- function(x, directed=FALSE) {\n  out_table <- matrix(rep(NA,32),16,2)\n  try({\n    rownames(out_table) <- c(\"1.1\",\"1.2\",\"1.3\",\"1.4\",\"2.1\",\"2.2\",\"2.3\",\"2.4\",\"3.1\",\"3.2\",\"3.3\",\"3.4\",\"4.1\",\"4.2\",\"4.3\",\"4.4\")\n    colnames(out_table) <- c(\"Sensitivity\", \"Specificity\")\n    all <- colnames(as.matrix(x[[1]]))\n    actual <- x[[4]]\n    \n    ## Case 1 = communities prespecified, no noise\n    b1 <- bridge(as.matrix(x[[1]]), communities= unlist(x[[3]]), directed=directed) # w/communities\n    strength <- b1$`Bridge Expected Influence (1-step)`; between <- b1$`Bridge Expected Influence (2-step)`; close <- b1$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    ### 1.1 = combined criteria\n    out_table[1, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    ### 1.2 = strength only\n    out_table[2, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    ### 1.3 = betweenness only\n    out_table[3, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    ### 1.4 = closeness only\n    out_table[4, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 2 = communities not specified, no noise\n    b2 <- bridge(as.matrix(x[[1]]), directed=directed) \n    strength <- b2$`Bridge Expected Influence (1-step)`; between <- b2$`Bridge Expected Influence (2-step)`; close <- b2$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[5, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[6, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[7, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[8, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 3 = communities prespecified, noise\n    b3 <- bridge(as.matrix(x[[2]]), communities= unlist(x[[3]]), directed=directed) \n    strength <- b3$`Bridge Expected Influence (1-step)`; between <- b3$`Bridge Expected Influence (2-step)`; close <- b3$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[9, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[10, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[11, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[12, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n    \n    ## Case 4 = communities not specified, noise\n    b4 <- bridge(as.matrix(x[[2]]), directed=directed)\n    strength <- b4$`Bridge Expected Influence (1-step)`; between <- b4$`Bridge Expected Influence (2-step)`; close <- b4$'Bridge Closeness'\n    pred_list <- predict_bridge(strength, between, close)\n    out_table[13, 1:2] <- sens_spec(all, pred_list[[1]], actual)\n    out_table[14, 1:2] <- sens_spec(all, pred_list[[2]], actual)\n    out_table[15, 1:2] <- sens_spec(all, pred_list[[3]], actual)\n    out_table[16, 1:2] <- sens_spec(all, pred_list[[4]], actual)\n  })\n  return(out_table)\n}\n\n\nundir_tests <- lapply(undir_sim_neg, FUN=check_bridge2)\ndir_tests <- lapply(dir_sim_neg, FUN=check_bridge2, directed=TRUE)\n\nav_mat_undir <- matrix(rep(NA, 32), 16,2)\nav_mat_dir <- matrix(rep(NA, 32), 16,2)\nfor(i in 1:16) {\n  for(j in 1:2){\n    vec1 <- sapply(undir_tests, function(l) l[i,j])\n    av_mat_undir[i,j] <- mean(na.omit(vec1))\n    vec2 <- sapply(dir_tests, function(l) l[i,j])\n    av_mat_dir[i,j] <- mean(na.omit(vec2))\n  }\n}\n\nav_mat_undir\nav_mat_dir\n\nfulltable_EI <- as.data.frame(matrix(rep(NA, 32*6), 32, 6))\ncolnames(fulltable_EI) <- c(\"Directed?\", \"Comm. Prespecified?\", \"Noise?\", \"Criteria\", \"Sensitivity\", \"Specificity\")\nfulltable_EI[1:16,5:6] <- av_mat_undir\nfulltable_EI[17:32, 5:6] <- av_mat_dir\nfulltable_EI$'Directed?' <- c(rep(\"Undirected\", 16), rep(\"Directed\", 16))\nfulltable_EI$'Criteria' <- rep(c(\"Combined\", \"EI1\", \"EI2\", \"Closeness\"),8)\nfulltable_EI$'Comm. Prespecified?' <- rep(c(rep(c(\"Yes\"), 4), rep(c(\"No\"), 4)), 4)\nfulltable_EI$'Noise?' <- rep(c(rep(\"No\", 8), rep(\"Yes\", 8)), 2)\n\nfulltable_EI <- fulltable_EI[fulltable_EI$Criteria %!in% c(\"Combined\", \"Closeness\"),]\n\n\n## Simulation results for bridge strength, betweenness, closeness\n\nfulltable2\n\n###################################################################################################\n# Study 2: simulation of contagion\n###################################################################################################\n\n# Simulation 2\n\npredict_bridge2 <- function(strength) {\n  pred_strength <- names(head(sort(strength, decreasing=TRUE), 5))\n  return(pred_strength)\n}\n\ntensteps_bridge <- function(netdata, directed=F, noiseparam=2) {\n  noisemat <- as.matrix(netdata[[noiseparam]])\n  b1 <- bridge(as.matrix(netdata[[2]]), communities= unlist(netdata[[3]]), directed=directed) \n  strength <- b1$'Bridge Strength'\n  b2 <- predict_bridge2(strength)\n  values <- vector()\n  for(i in 1:dim(noisemat)[1]) {\n    if(netdata[[3]][[i]][1]==1) {\n      values[i] <- 0.5\n    } else {values[i] <- 0}\n    if(colnames(netdata[[2]])[i] %in% b2) {values[i] <-0}\n  }\n  step <- function(x) {\n    out <- vector()\n    for(i in 1:dim(noisemat)[1]) {\n      out[i] <- x[i]+(sum(noisemat[-i,i] * x[-i])*0.01)\n      if(colnames(netdata[[2]])[i] %in% b2) {out[i] <-0}\n    }  \n    return(out)\n  }\n  values2 <- step(values)\n  values3 <- step(values2)\n  values4 <- step(values3)\n  values5 <- step(values4)\n  values6 <- step(values5)\n  values7 <- step(values6)\n  values8 <- step(values7)\n  values9 <- step(values8)\n  values10 <- step(values9)\n  res1 <- data.frame(values, values2, values3, values4, values5, values6, values7, values8, values9, values10)\n  outnodes <- colSums(res1[unlist(netdata[[3]]) != 1,])\n  return(outnodes)\n}\n\ntensteps_str <- function(netdata, directed=F, noiseparam=2) {\n  noisemat <- as.matrix(netdata[[noiseparam]])\n  b1 <- centralityTable(noisemat)\n  b1 <- b1[b1$measure==\"Strength\",]\n  b2 <- b1$value\n  names(b2) <- b1$node\n  b2 <- names(head(sort(b2, decreasing=TRUE), 5))  \n  values <- vector()\n  for(i in 1:dim(noisemat)[1]) {\n    if(netdata[[3]][[i]][1]==1) {\n      values[i] <- 0.5\n    } else {values[i] <- 0}\n    if(colnames(netdata[[2]])[i] %in% b2) {values[i] <-0}\n  }\n  step <- function(x) {\n    out <- vector()\n    for(i in 1:dim(noisemat)[1]) {\n      out[i] <- x[i]+(sum(noisemat[-i,i] * x[-i])*0.01)\n      if(colnames(netdata[[2]])[i] %in% b2) {out[i] <-0}\n    }  \n    return(out)\n  }\n  values2 <- step(values)\n  values3 <- step(values2)\n  values4 <- step(values3)\n  values5 <- step(values4)\n  values6 <- step(values5)\n  values7 <- step(values6)\n  values8 <- step(values7)\n  values9 <- step(values8)\n  values10 <- step(values9)\n  res1 <- data.frame(values, values2, values3, values4, values5, values6, values7, values8, values9, values10)\n  outnodes <- colSums(res1[unlist(netdata[[3]]) != 1,])\n  return(outnodes)\n}\n\ntensteps_bet <- function(netdata, directed=F, noiseparam=2) {\n  noisemat <- as.matrix(netdata[[noiseparam]])\n  b1 <- centralityTable(noisemat)\n  b1 <- b1[b1$measure==\"Betweenness\",]\n  b2 <- b1$value\n  names(b2) <- b1$node\n  b2 <- names(head(sort(b2, decreasing=TRUE), 5))\n  values <- vector()\n  for(i in 1:dim(noisemat)[1]) {\n    if(netdata[[3]][[i]][1]==1) {\n      values[i] <- 0.5\n    } else {values[i] <- 0}\n    if(colnames(netdata[[2]])[i] %in% b2) {values[i] <-0}\n  }\n  step <- function(x) {\n    out <- vector()\n    for(i in 1:dim(noisemat)[1]) {\n      out[i] <- x[i]+(sum(noisemat[-i,i] * x[-i])*0.01)\n      if(colnames(netdata[[2]])[i] %in% b2) {out[i] <-0}\n    }  \n    return(out)\n  }\n  values2 <- step(values)\n  values3 <- step(values2)\n  values4 <- step(values3)\n  values5 <- step(values4)\n  values6 <- step(values5)\n  values7 <- step(values6)\n  values8 <- step(values7)\n  values9 <- step(values8)\n  values10 <- step(values9)\n  res1 <- data.frame(values, values2, values3, values4, values5, values6, values7, values8, values9, values10)\n  outnodes <- colSums(res1[unlist(netdata[[3]]) != 1,])\n  return(outnodes)\n}\n\ntensteps_free <- function(netdata, directed=F, noiseparam=2) {\n  noisemat <- as.matrix(netdata[[noiseparam]])\n  values <- vector()\n  for(i in 1:dim(noisemat)[1]) {\n    if(netdata[[3]][[i]][1]==1) {\n      values[i] <- 0.5\n    } else {values[i] <- 0}\n  }\n  step <- function(x) {\n    out <- vector()\n    for(i in 1:dim(noisemat)[1]) {\n      out[i] <- x[i]+(sum(noisemat[-i,i] * x[-i])*0.01)\n    }  \n    return(out)\n  }\n  values2 <- step(values)\n  values3 <- step(values2)\n  values4 <- step(values3)\n  values5 <- step(values4)\n  values6 <- step(values5)\n  values7 <- step(values6)\n  values8 <- step(values7)\n  values9 <- step(values8)\n  values10 <- step(values9)\n  res1 <- data.frame(values, values2, values3, values4, values5, values6, values7, values8, values9, values10)\n  outnodes <- colSums(res1[unlist(netdata[[3]]) != 1,])\n  return(outnodes)\n}\n\n## Generate networks:\nundir_simulations <- mainSimU(500)\ndir_simulations <- mainSimD(500)\n\n## Noiseless\nnobridges_undir_noiseless <- lapply(undir_simulations, FUN = tensteps_bridge, noiseparam=1)\nnostrength_undir_noiseless <- lapply(undir_simulations, FUN = tensteps_str, noiseparam=1)\nnobet_undir_noiseless <- lapply(undir_simulations, FUN = tensteps_bet, noiseparam=1)\nfree_undir_noiseless <- lapply(undir_simulations, FUN = tensteps_free, noiseparam=1)\n\nnobridges_dir_noiseless <- lapply(dir_simulations, FUN = tensteps_bridge, noiseparam=1)\nnostrength_dir_noiseless <- lapply(dir_simulations, FUN = tensteps_str, noiseparam=1)\nnobet_dir_noiseless <- lapply(dir_simulations, FUN = tensteps_bet, noiseparam=1)\nfree_dir_noiseless <- lapply(dir_simulations, FUN = tensteps_free, noiseparam=1)\n\n## Find averages\n\nstepmeans <- function(x) {\n  m <- do.call(rbind, x)\n  out <- vector()\n  for(i in 1:dim(m)[2]) {\n    out[i] <- mean(m[,i])\n  }\n  return(out)\n}\nnobridges_undir_mean <- stepmeans(nobridges_undir)\nnostrength_undir_mean <- stepmeans(nostrength_undir)\nnobet_undir_mean <- stepmeans(nobet_undir)\nfree_undir_mean <- stepmeans(free_undir)\n\nnobridges_dir_mean <- stepmeans(nobridges_dir)\nnostrength_dir_mean <- stepmeans(nostrength_dir)\nnobet_dir_mean <- stepmeans(nobet_dir)\nfree_dir_mean <- stepmeans(free_dir)\n\nnobridges_undir_noiseless_mean <- stepmeans(nobridges_undir_noiseless)\nnostrength_undir_noiseless_mean <- stepmeans(nostrength_undir_noiseless)\nnobet_undir_noiseless_mean <- stepmeans(nobet_undir_noiseless)\nfree_undir_noiseless_mean <- stepmeans(free_undir_noiseless)\n\nnobridges_dir_noiseless_mean <- stepmeans(nobridges_dir_noiseless)\nnostrength_dir_noiseless_mean <- stepmeans(nostrength_dir_noiseless)\nnobet_dir_noiseless_mean <- stepmeans(nobet_dir_noiseless)\nfree_dir_noiseless_mean <- stepmeans(free_dir_noiseless)\n\n## Table\n\ntable4 <- rbind(nobridges_undir_noiseless_mean, nostrength_undir_noiseless_mean, nobet_undir_noiseless_mean,\n                nobridges_dir_noiseless_mean, nostrength_dir_noiseless_mean, nobet_dir_noiseless_mean,\n                nobridges_undir_mean, nostrength_undir_mean, nobet_undir_mean,\n                nobridges_dir_mean, nostrength_dir_mean, nobet_undir_mean)\ndirs <- c(rep(\"Undirected\", 3), rep(\"Directed\", 3), rep(\"Undirected\", 3), rep(\"Directed\", 3))\nnoise <- c(rep(\"Noiseless\", 6), rep(\"Noisey\", 6))\ntable5 <- cbind(noise, dirs, table4)\ntable5 <- table5[,c(1:2, 5, 7, 12)]\n\n\n## Plots\nx11()\nplot(1:10, free_undir_mean, ylim=c(0,1.5))\nlines(free_undir_mean, col=\"green\")\nlines(nobridges_undir_mean, col=\"purple\")\nlines(nostrength_undir_mean, col=\"red\")\nlines(nobet_undir_mean, col=\"blue\")\n\nx11()\nplot(0, type=\"n\", xlim=c(0, 10), ylim=c(0,2.5))\nlines(free_dir_mean, col=\"green\")\nlines(nobridges_dir_mean, col=\"purple\")\nlines(nostrength_dir_mean, col=\"red\")\nlines(nobet_dir_mean, col=\"blue\")\n\nx11()\nplot(0, type=\"n\", xlim=c(0, 10), ylim=c(0,0.1))\nlines(nobridges_undir_noiseless_mean, col=\"green\")\nlines(nostrength_undir_noiseless_mean, col=\"purple\")\nlines(nobet_undir_noiseless_mean, col=\"red\")\n\nx11()\nplot(0, type=\"n\", xlim=c(0, 10), ylim=c(0,0.1))\nlines(nobridges_dir_noiseless_mean, lty=\"solid\")\nlines(nostrength_dir_noiseless_mean, lty=\"dashed\")\nlines(nobet_dir_noiseless_mean, lty=\"dotted\")\n\nx11()\nplot(0, type=\"n\", xlim=c(1, 10), ylim=c(0,0.09), xlab=\"Iterations\",\n     ylab=\"Total contagion\")\nlines(nobridges_undir_noiseless_mean, lty=\"solid\")\nlines(nostrength_undir_noiseless_mean, lty=\"dashed\")\nlines(nobet_undir_noiseless_mean, lty=\"dotted\")\nlegend(x=1, y=0.09, legend=c(\"Strength\", \"Betweenness\", \"Bridge strength\"),\n       lty=c(\"dashed\", \"dotted\", \"solid\"))\n\n###################################################################################################\n# Study 3: empirical analyses\n###################################################################################################\n\n## Note: we cannot provide full code, as not all of the original data is ours to share.\n## Therefore, we provide the code for the general process we applied\n\nrequire(networktools)\nrequire(igraph)\nrequire(qgraph)\n\n## Generic function for producing plot and bridges\n## Index is 1 strength, 2 between, 3 close, 4 EI, 5 EI2\n\nfull_bridge_workup <- function(data, index, communities, file){\n  w1 <- bridge(data, communities=communities)\n  pdf(paste(\"BridgeCentrality_\", file), width=18, height=12)\n  plot(bridge(data, communities=communities), order=\"value\")\n  dev.off()\n  bridge_w1 <- names(w1[[index]][w1[[index]]>quantile(w1[[index]], probs=0.80, na.rm=TRUE)])\n  bridge_num_w1 <- which(names(w1[[index]]) %in% bridge_w1)\n  new_communities <- vector()\n  for(i in 1:length(w1[[index]])) {\n    if(i %in% bridge_num_w1) {\n      new_communities[i] <- \"Bridge\"\n    } else {new_communities[i] <- communities[i]}\n  }\n  new_groups <- list()\n  for(i in 1:length(unique(new_communities))){\n    new_groups[[i]] <- which(new_communities %in% unique(new_communities)[i])\n  }\n  names(new_groups) <- unique(new_communities)\n  pdf(paste(\"BridgePlot_\", file), width=24, height=24)\n  qgraph(data, layout=\"spring\", \n         groups = new_groups,\n         colors = c(\"lightsalmon\", \"lightblue\", \"indianred1\", \"lightgreen\", 1:30))\n  dev.off()\n  return(bridge_w1)\n}\n\nbridges <- full_bridge_workup(YOURNETWORKHERE)\nbridges\n\n",
    "created" : 1538401166514.000,
    "dirty" : false,
    "encoding" : "ASCII",
    "folds" : "",
    "hash" : "3300159635",
    "id" : "6123EA56",
    "lastKnownWriteTime" : 1529137915,
    "path" : "~/Dropbox/Igor Marchetti/Network Analyses/Articles/bridge centrality/Code.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}